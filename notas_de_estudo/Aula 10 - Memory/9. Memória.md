Documenta√ß√£o:
https://python.langchain.com/v0.2/docs/how_to/chatbots_memory/
https://python.langchain.com/docs/integrations/memory/
https://python.langchain.com/v0.2/docs/how_to/message_history/
# Defini√ß√£o

Passar o estado da conversa para dentro e para fora de uma cadeia √© necess√°rio para se construir um chatbot. Isso √© o que chamamos de hist√≥rico de conversa, ou seja, quando voc√™ armazenas as trocas de mensagens de uma sess√£o de conversa e enviar para o modelo para que ele possa entender o contexto conversado at√© aquele ponto da conversa.

Para isso, hoje a documenta√ß√£o do LangChain sugere que usemos o conceito de estados (`state`) do LagnGraph para controlar o hist√≥rico de mensagens, mas eles fornecem uma op√ß√£o com classes puras e que n√£o ser√£o descontinuadas do pr√≥prio LangChain: `RunnableWithMessageHistory`, que nos permite adicionar hist√≥rico de mensagens a certos tipos de cadeias. 

A classe `RunnableWithMessageHistory` envolve outro `Runnable` (como por exemplo nossa chain) e gerencia o hist√≥rico de mensagens de chat para ele. Especificamente, ela carrega mensagens anteriores na conversa **ANTES** de pass√°-la para o `Runnable`, e salva a resposta gerada como uma mensagem **DEPOIS** de chamar o `runnable`.  Al√©m disso, esta classe permite isolar uma conversa da outra usando um `session_id`  sendo passado na configura√ß√£o ao chamar o runnable, e usa isso para procurar o hist√≥rico de conversas relevante.

![[Pasted image 20241215140543.png]]

# # Como Armazenar e Carregar Mensagens em Fluxos Conversacionais com LangChain

## Passo 1: Compreendendo os Conceitos Fundamentais

### O que √© `session_id`?

O `session_id` √© um identificador exclusivo para uma sess√£o ou thread de conversa. Ele √© usado para associar mensagens de entrada e sa√≠da a uma conversa espec√≠fica, possibilitando o gerenciamento de m√∫ltiplos di√°logos de forma independente.

### O que √© `BaseChatMessageHistory`?

A classe `BaseChatMessageHistory` √© usada para salvar e carregar objetos de mensagens. Ela √© essencial para gerenciar o hist√≥rico das conversas, sendo invocada por componentes como o `RunnableWithMessageHistory`. Geralmente, essa classe √© inicializada com um `session_id`.

---

## Passo 2: Criando uma Fun√ß√£o `get_session_history`

Para implementar o gerenciamento de hist√≥rico de mensagens, precisamos criar uma fun√ß√£o chamada `get_session_history`. Essa fun√ß√£o ser√° respons√°vel por retornar um objeto de hist√≥rico de mensagens associado a um `session_id`.

Neste exemplo, utilizaremos o **SQLite** para armazenar o hist√≥rico de mensagens de forma simples e pr√°tica.

### C√≥digo de Implementa√ß√£o

Antes de come√ßar, certifique-se de que o banco de dados local esteja limpo, excluindo-o do diret√≥rio, se existir:

Agora, implemente a fun√ß√£o `get_session_history`:

```python
from langchain_community.chat_message_histories import SQLChatMessageHistory

# Fun√ß√£o para retornar o hist√≥rico de mensagens com base no session_id
def get_session_history(session_id):
    return SQLChatMessageHistory(session_id, "sqlite:///memory.db")
```

Aqui est√° o que acontece no c√≥digo acima:

1. **Importa√ß√£o do `SQLChatMessageHistory`**: Este √© um dos adaptadores dispon√≠veis para gerenciar o hist√≥rico de mensagens, usando um banco SQLite como backend.

2. **Fun√ß√£o `get_session_history`**: Retorna um objeto `SQLChatMessageHistory` associado a um `session_id` espec√≠fico. O banco de dados √© definido pelo URI `sqlite:///memory.db`.

---

## Passo 3: Utilizando o Hist√≥rico em Seus Fluxos

Depois de implementar a fun√ß√£o `get_session_history`, voc√™ pode integr√°-la com o `RunnableWithMessageHistory`. Este componente ser√° respons√°vel por conectar seu modelo de linguagem com o hist√≥rico de mensagens, permitindo que o contexto seja mantido durante a conversa.

**Usando Dicion√°rios como Entrada e Sa√≠da**

Se o seu fluxo envolve prompts com vari√°veis din√¢micas, voc√™ pode usar um **dicion√°rio** para entrada e sa√≠da. Nesse caso, √© necess√°rio configurar:

1. **`input_messages_key`**: Chave no dicion√°rio que cont√©m a mensagem de entrada.
2. **`history_messages_key`**: Chave que ser√° usada para armazenar mensagens hist√≥ricas.

#### C√≥digo:

```python
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.runnables.history import RunnableWithMessageHistory

# Configurando o prompt
prompt = ChatPromptTemplate.from_messages(
    [
        ("system", "Voc√™ √© um assistente que responde em {language}. Use no m√°ximo 20 palavras."),
        MessagesPlaceholder(variable_name="history"),
        ("human", "{input}"),
    ]
)

# Conectando o prompt ao modelo
runnable = prompt | llm

runnable_with_history = RunnableWithMessageHistory(
    runnable,
    get_session_history,
    input_messages_key="input",
    history_messages_key="history",
)

# Invocando com vari√°veis din√¢micas
response = runnable_with_history.invoke(
    {"language": "italian", "input": "hi im bob!"},
    config={"configurable": {"session_id": "2"}},
)
print(response)
```

---

### Configura√ß√£o Avan√ßada com Chaves Personalizadas

Voc√™ pode adicionar camadas de personaliza√ß√£o no rastreamento de hist√≥rico, por exemplo, usando identificadores como `user_id` e `conversation_id`. Isso permite gerenciar m√∫ltiplos usu√°rios em um √∫nico sistema.

#### C√≥digo:

```python
from langchain_core.runnables import ConfigurableFieldSpec

def get_session_history(user_id: str, conversation_id: str):
    return SQLChatMessageHistory(f"{user_id}--{conversation_id}", "sqlite:///memory.db")

runnable_with_history = RunnableWithMessageHistory(
    runnable,
    get_session_history,
    input_messages_key="input",
    history_messages_key="history",
    history_factory_config=[
        ConfigurableFieldSpec(
            id="user_id",
            annotation=str,
            name="User ID",
            description="Identificador √∫nico para o usu√°rio.",
        ),
        ConfigurableFieldSpec(
            id="conversation_id",
            annotation=str,
            name="Conversation ID",
            description="Identificador √∫nico para a conversa.",
        ),
    ],
)

# Invocando com identificadores personalizados
response = runnable_with_history.invoke(
    {"language": "italian", "input": "hi im bob!"},
    config={"configurable": {"user_id": "123", "conversation_id": "1"}},
)
print(response)
```

---
### Observa√ß√£o Importante

Ao usar o SQLite para armazenar mensagens, tenha em mente que este m√©todo √© mais adequado para testes e pequenos projetos. Para aplica√ß√µes em produ√ß√£o, √© recomend√°vel usar sistemas de banco de dados mais robustos, como Redis ou PostgreSQL.

### Outros tipos de gerenciadores de mensagem

H√° outras formas de fazer o armazenamento e gerenciamento de mensagens de hist√≥ricos, convido voc√™ a explorar a [documenta√ß√£o de integra√ß√µes do LangChain](https://python.langchain.com/v0.2/docs/integrations/memory/).

# Controlando o tamanho do contexto de hist√≥rico

LLMs e modelos de bate-papo t√™m janelas de contexto limitadas e, mesmo que voc√™ n√£o esteja atingindo os limites diretamente, voc√™ pode querer limitar a quantidade de distra√ß√£o com a qual o modelo tem que lidar. Uma solu√ß√£o √© 'cortar' as mensagens hist√≥ricas antes de pass√°-las para o modelo. Para que voc√™ fa√ßa esse corte, voc√™ precisa usar uma fun√ß√£o do LangChain que faz este trabalho para voc√™.

Neste exemplo, `trim_messages` gerencia o total de mensagens utilizando a estrat√©gia `last`, ou seja, pegando sempre as √∫ltimas mensagens trocadas entre o usu√°rio e o chatbot em um tamanho de 2 ao considerar `token_counter=len`.

```python
from operator import itemgetter

from langchain_core.messages import trim_messages
from langchain_core.runnables import RunnablePassthrough

trimmer = trim_messages(strategy="last", max_tokens=2, token_counter=len)

chain_with_trimming = (
    RunnablePassthrough.assign(chat_history=itemgetter("chat_history") | trimmer)
    | prompt
    | chat
)

chain_with_trimmed_history = RunnableWithMessageHistory(
    chain_with_trimming,
    get_session_history,
    input_messages_key="input",
    history_messages_key="chat_history",
)
```

# Pr√°tica

Agora vamos desenvolver um chatbot com gerenciamento de hist√≥rico. Para isso, vamos resgatar nosso assistente de atendimento odontol√≥gico que criamos em aulas anteriores. Com algumas modifica√ß√µes e para simplificar o processo, vou tirar a chain de roteamento inicial e deixar apenas o assistente autom√°tico de atendimento. Com isso podemos inserir um gerenciador de hist√≥rico usando o SQLite.

```python
from dotenv import load_dotenv  
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder  
from langchain_core.output_parsers import StrOutputParser  
from langchain_openai import ChatOpenAI  
from langchain_community.chat_message_histories import SQLChatMessageHistory  
from langchain_core.runnables.history import RunnableWithMessageHistory  
  
# Carregar as chas APIs presentes no arquivo .env  
load_dotenv()  
# --------------------------------------------------------------------------------  
  
## Criando o gestor de mem√≥ria (hist√≥rico)  
# Fun√ß√£o para retornar o hist√≥rico de mensagens com base no session_id  
  
def get_session_history(session_id):  
    return SQLChatMessageHistory(session_id, connection="sqlite:///memory.db")  
  
# --------------------------------------------------------------------------------  
  
# Instancias um chatmodel para comunicarmos com os modelos LLMs  
model = ChatOpenAI(model="gpt-4o", temperature=0.2)  
  
# --------------------------------------------------------------------------------  
  
# Definindo o prompt de chatbot que tira duvidas do usu√°rio:  
  
sys_chatbot_prompt = """ Voc√™ √© um assistente de uma clinica odontol√≥gica e tem como objetivo responder √† perguntas dos clientes. A seguir voc√™ \  encontra a FAQ do nosso site, use essas informa√ß√µes para realizar o atendimento e tirar d√∫vidas. Caso voc√™ desconhe√ßa alguma \  informa√ß√£o, n√£o invente. Seja sempre amig√°vel e esteja disposto a ajudar!    
**FAQ - Cl√≠nica Odontol√≥gica**  1. **Quais servi√ßos a cl√≠nica oferece?**      
Oferecemos tratamentos como limpeza dental, clareamento, ortodontia, implantes, pr√≥teses, tratamento de canal e est√©tica dental.  2. **A cl√≠nica aceita conv√™nios?**      
Sim, trabalhamos com os principais conv√™nios odontol√≥gicos. Consulte nossa equipe para verificar se aceitamos o seu.  3. **Como agendar uma consulta?**      
Voc√™ pode agendar sua consulta pelo telefone, WhatsApp ou diretamente em nosso site.  4. **Quanto tempo dura uma consulta?**      
Depende do procedimento, mas consultas de rotina geralmente duram entre 30 e 60 minutos.  5. **Voc√™s atendem emerg√™ncias?**      
Sim, oferecemos atendimento emergencial para dores agudas, traumas ou casos de urg√™ncia.  6. **√â poss√≠vel parcelar tratamentos?**      
Sim, oferecemos op√ß√µes de parcelamento. Entre em contato para conhecer os detalhes.  7. **Crian√ßas podem ser atendidas na cl√≠nica?**      
Sim, contamos com profissionais especializados em odontopediatria para cuidar dos sorrisos dos pequenos.  8. **O clareamento dental √© seguro?**      
Sim, nossos tratamentos de clareamento s√£o realizados com t√©cnicas e produtos seguros, supervisionados por especialistas.  Se tiver mais d√∫vidas, entre em contato conosco! üòä  """  
  
prompt_template_chatbot = ChatPromptTemplate.from_messages([  
    ("system", sys_chatbot_prompt),  
    MessagesPlaceholder(variable_name="history"),  
    ("human", "D√∫vida do usu√°rio: {input}"),  
]  
)  
  
chain_chatbot = prompt_template_chatbot | model | StrOutputParser()  
  
# --------------------------------------------------------------------------------  
## Encapsulando nossa chain com a classe de gest√£o de mensagens de hist√≥rico  
runnable_with_history = RunnableWithMessageHistory(  
    chain_chatbot,  
    get_session_history,  
    input_messages_key="input",  
    history_messages_key="history",  
)  
# --------------------------------------------------------------------------------  
  
  
# Executando nossa chain principal.  
result = runnable_with_history.invoke(  
    {"input": "Ol√°, tudo bem??"},  
    config={"configurable": {"session_id": "1"}},  
)  
  
# --------------------------------------------------------------------------------  
# Imprimindo a saida.  
print("---------------")  
print(result)  
print("---------------")
```